// This file was automatically generated by Caper.
// (http://jonigata.github.io/caper/caper.html)

using System.Collections.Generic;
using System.Diagnostics;



namespace Calc
{
    enum Token
    {
        Eof,
        Add,
        Div,
        Mul,
        Number,
        Sub,
    }

    interface ISemanticAction
    {
        void DebugLog(string name, Token token, int value);
        void SyntaxError(string name, Token token, params Token[] tokens);
        int Identity(int arg0);
        int MakeAdd(int arg0, int arg1);
        int MakeDiv(int arg0, int arg1);
        int MakeMul(int arg0, int arg1);
        int MakeSub(int arg0, int arg1);
    }

    class Stack<T>
    {
        public Stack() { }

        public void RollbackTmp() {
            _gap = _stack.Count;
            _tmp.Clear();
        }

        public void CommitTmp() {
            _stack.RemoveRange(_gap, _stack.Count - _gap);
            _stack.AddRange(_tmp);
            _tmp.Clear();
        }

        public void Push(T value) {
            _tmp.Add(value);
        }

        public void Pop(int count) {
            if (_tmp.Count < count) {
                _gap -= count - _tmp.Count;
                _tmp.Clear();
            } else {
                _tmp.RemoveRange(_tmp.Count - count, count);
            }
        }

        public T Top() {
            return this[1];
        }

        public T this[int @base, int index] => this[@base - index];

        public void Clear() {
            _stack.Clear();
            _tmp.Clear();
            _gap = 0;
        }

        public bool Empty() {
            return _tmp.Count == 0 && _gap == 0;
        }

        public int Depth() {
            return _gap + _tmp.Count;
        }

        T this[int index] {
            get => index <= _tmp.Count ? _tmp[^index] : _stack[_gap - index + _tmp.Count];
            set {
                if (index <= _tmp.Count) {
                    _tmp[^index] = value;
                } else {
                    _stack[_gap - index + _tmp.Count] = value;
                }
            }
        }

        public void SwapTopAndSecond() {
            Debug.Assert(2 <= Depth());
            (this[2], this[1]) = (this[1], this[2]);
        }

        readonly List<T> _stack = new();
        readonly List<T> _tmp = new();
        int _gap = 0;
    }

    class Parser
    {
        enum NonTerminal
        {
            Expr,
            Term,
        }

        public Parser(ISemanticAction sa) {
            _entries = new List<TableEntry> {
                new(State0, Goto0, false),
                new(State1, Goto1, false),
                new(State2, Goto2, false),
                new(State3, Goto3, false),
                new(State4, Goto4, false),
                new(State5, Goto5, false),
                new(State6, Goto6, false),
                new(State7, Goto7, false),
                new(State8, Goto8, false),
                new(State9, Goto9, false),
                new(State10, Goto10, false),
                new(State11, Goto11, false),
            };
            _stack = new Stack<StackFrame>();
            _action = sa;
            Reset();
        }

        public void Reset() {
            _error = false;
            _accepted = false;
            ClearStack();
            RollbackTmpStack();
            PushStack(0, default);
            CommitTmpStack();
        }

        public bool Post(Token token) {
            Debug.Assert(token == Token.Eof || token == Token.Add || token == Token.Div || token == Token.Mul || token == Token.Sub);
            return Post(token, default);
        }

        public bool Post(Token token, int value) {
            RollbackTmpStack();
            _error = false;
            while (StackTop().Entry.State(token, value)) {
                // may throw
            }
            if (!_error) {
                CommitTmpStack();
            } else {
                Recover(token, value);
            }
            return _accepted || _error;
        }

        public bool Accept(out int value) {
            Debug.Assert(_accepted);
            value = !_error ? _acceptedValue : default;
            return !_error;
        }

        public bool Error() { return _error; }

        delegate bool StateType(Token token, int value);
        delegate int GotoType(NonTerminal nonTerminal);

        readonly ISemanticAction _action;
        bool _accepted;
        bool _error;
        int _acceptedValue;

        readonly struct TableEntry
        {
            public readonly StateType State;
            public readonly GotoType Goto;
            public readonly bool HandleError;
            public TableEntry(StateType statef, GotoType gotof, bool handleError) {
                State = statef;
                Goto = gotof;
                HandleError = handleError;
            }
        }

        readonly struct StackFrame
        {
            public readonly TableEntry Entry;
            public readonly int Value;
            public readonly int SequenceLength;
            public StackFrame(TableEntry entry, int value, int sequenceLength) {
                Entry = entry;
                Value = value;
                SequenceLength = sequenceLength;
            }
        }

        readonly List<TableEntry> _entries;
        readonly Stack<StackFrame> _stack;

        void PushStack(int stateIndex, int value, int sequenceLength = 0) {
            _stack.Push(new StackFrame(_entries[stateIndex], value, sequenceLength));
        }

        void PopStack(int n) {
            _stack.Pop(n);
        }

        StackFrame StackTop() {
            return _stack.Top();
        }

        int GetArg(int @base, int index) {
            return _stack[@base, index].Value;
        }

        void ClearStack() {
            _stack.Clear();
        }

        void RollbackTmpStack() {
            _stack.RollbackTmp();
        }

        void CommitTmpStack() {
            _stack.CommitTmp();
        }

        void Recover(Token token, int value) {
        }

        void CallNothing(NonTerminal nonTerminal, int @base) {
            PopStack(@base);
            var destIndex = StackTop().Entry.Goto(nonTerminal);
            PushStack(destIndex, default);
        }

        void Call0MakeAdd(NonTerminal nonTerminal, int @base, int arg0Index, int arg1Index) {
            var arg0 = GetArg(@base, arg0Index);
            var arg1 = GetArg(@base, arg1Index);
            var r = _action.MakeAdd(arg0, arg1);
            PopStack(@base);
            var destIndex = StackTop().Entry.Goto(nonTerminal);
            PushStack(destIndex, r);
        }

        void Call0MakeSub(NonTerminal nonTerminal, int @base, int arg0Index, int arg1Index) {
            var arg0 = GetArg(@base, arg0Index);
            var arg1 = GetArg(@base, arg1Index);
            var r = _action.MakeSub(arg0, arg1);
            PopStack(@base);
            var destIndex = StackTop().Entry.Goto(nonTerminal);
            PushStack(destIndex, r);
        }

        void Call0Identity(NonTerminal nonTerminal, int @base, int arg0Index) {
            var arg0 = GetArg(@base, arg0Index);
            var r = _action.Identity(arg0);
            PopStack(@base);
            var destIndex = StackTop().Entry.Goto(nonTerminal);
            PushStack(destIndex, r);
        }

        void Call0MakeDiv(NonTerminal nonTerminal, int @base, int arg0Index, int arg1Index) {
            var arg0 = GetArg(@base, arg0Index);
            var arg1 = GetArg(@base, arg1Index);
            var r = _action.MakeDiv(arg0, arg1);
            PopStack(@base);
            var destIndex = StackTop().Entry.Goto(nonTerminal);
            PushStack(destIndex, r);
        }

        void Call0MakeMul(NonTerminal nonTerminal, int @base, int arg0Index, int arg1Index) {
            var arg0 = GetArg(@base, arg0Index);
            var arg1 = GetArg(@base, arg1Index);
            var r = _action.MakeMul(arg0, arg1);
            PopStack(@base);
            var destIndex = StackTop().Entry.Goto(nonTerminal);
            PushStack(destIndex, r);
        }

        bool State0(Token token, int value) {
            _action.DebugLog(nameof(State0), token, value);
            switch (token) {
            case Token.Number:
                // Shift
                PushStack(/*State*/ 7, value);
                return false;
            default:
                _action.SyntaxError(nameof(State0), token, Token.Number);
                _error = true;
                return false;
            }
        }

        int Goto0(NonTerminal nonTerminal) {
            switch (nonTerminal) {
            case NonTerminal.Expr: return 1;
            case NonTerminal.Term: return 2;
            default: Debug.Assert(false); return 0;
            }
        }

        bool State1(Token token, int value) {
            _action.DebugLog(nameof(State1), token, value);
            switch (token) {
            case Token.Eof:
                // Accept
                _accepted = true;
                _acceptedValue = GetArg(1, 0);
                return false;
            case Token.Add:
                // Shift
                PushStack(/*State*/ 3, value);
                return false;
            case Token.Sub:
                // Shift
                PushStack(/*State*/ 5, value);
                return false;
            default:
                _action.SyntaxError(nameof(State1), token, Token.Eof, Token.Add, Token.Sub);
                _error = true;
                return false;
            }
        }

        int Goto1(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State2(Token token, int value) {
            _action.DebugLog(nameof(State2), token, value);
            switch (token) {
            case Token.Div:
                // Shift
                PushStack(/*State*/ 10, value);
                return false;
            case Token.Mul:
                // Shift
                PushStack(/*State*/ 8, value);
                return false;
            case Token.Eof:
            case Token.Add:
            case Token.Sub:
                // Reduce
                Call0Identity(NonTerminal.Expr, /*Pop*/ 1, 0);
                return true;
            default:
                _action.SyntaxError(nameof(State2), token, Token.Eof, Token.Add, Token.Div, Token.Mul, Token.Sub);
                _error = true;
                return false;
            }
        }

        int Goto2(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State3(Token token, int value) {
            _action.DebugLog(nameof(State3), token, value);
            switch (token) {
            case Token.Number:
                // Shift
                PushStack(/*State*/ 7, value);
                return false;
            default:
                _action.SyntaxError(nameof(State3), token, Token.Number);
                _error = true;
                return false;
            }
        }

        int Goto3(NonTerminal nonTerminal) {
            switch (nonTerminal) {
            case NonTerminal.Term: return 4;
            default: Debug.Assert(false); return 0;
            }
        }

        bool State4(Token token, int value) {
            _action.DebugLog(nameof(State4), token, value);
            switch (token) {
            case Token.Div:
                // Shift
                PushStack(/*State*/ 10, value);
                return false;
            case Token.Mul:
                // Shift
                PushStack(/*State*/ 8, value);
                return false;
            case Token.Eof:
            case Token.Add:
            case Token.Sub:
                // Reduce
                Call0MakeAdd(NonTerminal.Expr, /*Pop*/ 3, 0, 2);
                return true;
            default:
                _action.SyntaxError(nameof(State4), token, Token.Eof, Token.Add, Token.Div, Token.Mul, Token.Sub);
                _error = true;
                return false;
            }
        }

        int Goto4(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State5(Token token, int value) {
            _action.DebugLog(nameof(State5), token, value);
            switch (token) {
            case Token.Number:
                // Shift
                PushStack(/*State*/ 7, value);
                return false;
            default:
                _action.SyntaxError(nameof(State5), token, Token.Number);
                _error = true;
                return false;
            }
        }

        int Goto5(NonTerminal nonTerminal) {
            switch (nonTerminal) {
            case NonTerminal.Term: return 6;
            default: Debug.Assert(false); return 0;
            }
        }

        bool State6(Token token, int value) {
            _action.DebugLog(nameof(State6), token, value);
            switch (token) {
            case Token.Div:
                // Shift
                PushStack(/*State*/ 10, value);
                return false;
            case Token.Mul:
                // Shift
                PushStack(/*State*/ 8, value);
                return false;
            case Token.Eof:
            case Token.Add:
            case Token.Sub:
                // Reduce
                Call0MakeSub(NonTerminal.Expr, /*Pop*/ 3, 0, 2);
                return true;
            default:
                _action.SyntaxError(nameof(State6), token, Token.Eof, Token.Add, Token.Div, Token.Mul, Token.Sub);
                _error = true;
                return false;
            }
        }

        int Goto6(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State7(Token token, int value) {
            _action.DebugLog(nameof(State7), token, value);
            switch (token) {
            case Token.Eof:
            case Token.Add:
            case Token.Div:
            case Token.Mul:
            case Token.Sub:
                // Reduce
                Call0Identity(NonTerminal.Term, /*Pop*/ 1, 0);
                return true;
            default:
                _action.SyntaxError(nameof(State7), token, Token.Eof, Token.Add, Token.Div, Token.Mul, Token.Sub);
                _error = true;
                return false;
            }
        }

        int Goto7(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State8(Token token, int value) {
            _action.DebugLog(nameof(State8), token, value);
            switch (token) {
            case Token.Number:
                // Shift
                PushStack(/*State*/ 9, value);
                return false;
            default:
                _action.SyntaxError(nameof(State8), token, Token.Number);
                _error = true;
                return false;
            }
        }

        int Goto8(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State9(Token token, int value) {
            _action.DebugLog(nameof(State9), token, value);
            switch (token) {
            case Token.Eof:
            case Token.Add:
            case Token.Div:
            case Token.Mul:
            case Token.Sub:
                // Reduce
                Call0MakeMul(NonTerminal.Term, /*Pop*/ 3, 0, 2);
                return true;
            default:
                _action.SyntaxError(nameof(State9), token, Token.Eof, Token.Add, Token.Div, Token.Mul, Token.Sub);
                _error = true;
                return false;
            }
        }

        int Goto9(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State10(Token token, int value) {
            _action.DebugLog(nameof(State10), token, value);
            switch (token) {
            case Token.Number:
                // Shift
                PushStack(/*State*/ 11, value);
                return false;
            default:
                _action.SyntaxError(nameof(State10), token, Token.Number);
                _error = true;
                return false;
            }
        }

        int Goto10(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State11(Token token, int value) {
            _action.DebugLog(nameof(State11), token, value);
            switch (token) {
            case Token.Eof:
            case Token.Add:
            case Token.Div:
            case Token.Mul:
            case Token.Sub:
                // Reduce
                Call0MakeDiv(NonTerminal.Term, /*Pop*/ 3, 0, 2);
                return true;
            default:
                _action.SyntaxError(nameof(State11), token, Token.Eof, Token.Add, Token.Div, Token.Mul, Token.Sub);
                _error = true;
                return false;
            }
        }

        int Goto11(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

    }
}
