// This file was automatically generated by Caper.
// (http://jonigata.github.io/caper/caper.html)

using System.Collections.Generic;
using System.Diagnostics;

namespace calc
{
    enum Token {
        token_eof,
        token_Add,
        token_Div,
        token_Mul,
        token_Number,
        token_Sub,
    }

    interface ISemanticAction<T>
    {
        void SyntaxError();
        void StackOverflow();
        T Fromint(int value);
        int Toint(T value);
        int Identity(int arg0);
        int MakeAdd(int arg0, int arg1);
        int MakeDiv(int arg0, int arg1);
        int MakeMul(int arg0, int arg1);
        int MakeSub(int arg0, int arg1);
    }

    class Stack<T>
    {
        public Stack() { }

        public void RollbackTmp() {
            _gap = _stack.Count;
            _tmp.Clear();
        }

        public void CommitTmp() {
            _stack.RemoveRange(_gap, _stack.Count - _gap);
            _stack.AddRange(_tmp);
            _tmp.Clear();
        }

        public bool Push(T value) {
            _tmp.Add(value);
            return true;
        }

        public void Pop(int count) {
            if (_tmp.Count < count) {
                _gap -= count - _tmp.Count;
                _tmp.Clear();
            } else {
                _tmp.RemoveRange(_tmp.Count - count, count);
            }
        }

        public T Top() {
            return this[1];
        }

        public T this[int @base, int index] => this[@base - index];

        public void Clear() {
            _stack.Clear();
            _tmp.Clear();
            _gap = 0;
        }

        public bool Empty() {
            return _tmp.Count == 0 && _gap == 0;
        }

        public int Depth() {
            return _gap + _tmp.Count;
        }

        T this[int index] {
            get => index <= _tmp.Count ? _tmp[^index] : _stack[_gap - index + _tmp.Count];
            set {
                if (index <= _tmp.Count) {
                    _tmp[^index] = value;
                } else {
                    _stack[_gap - index + _tmp.Count] = value;
                }
            }
        }

        public void SwapTopAndSecond() {
            Debug.Assert(2 <= Depth());
            (this[2], this[1]) = (this[1], this[2]);
        }

        readonly List<T> _stack = new List<T>();
        readonly List<T> _tmp = new List<T>();
        int _gap = 0;
    }

    class Parser<TValue>
    {
        enum NonTerminal {
            NonTerminal_Expr,
            NonTerminal_Term,
        }

        public Parser(ISemanticAction<TValue> sa) {
            _entries = new List<TableEntry> {
                new TableEntry(State0, Goto0, false),
                new TableEntry(State1, Goto1, false),
                new TableEntry(State2, Goto2, false),
                new TableEntry(State3, Goto3, false),
                new TableEntry(State4, Goto4, false),
                new TableEntry(State5, Goto5, false),
                new TableEntry(State6, Goto6, false),
                new TableEntry(State7, Goto7, false),
                new TableEntry(State8, Goto8, false),
                new TableEntry(State9, Goto9, false),
                new TableEntry(State10, Goto10, false),
                new TableEntry(State11, Goto11, false),
            };
            _stack = new Stack<StackFrame>();
            _action = sa;
            Reset();
        }

        public void Reset() {
            _error = false;
            _accepted = false;
            ClearStack();
            RollbackTmpStack();
            if (PushStack(0, default)) {
                CommitTmpStack();
            } else {
                _action.StackOverflow();
                _error = true;
            }
        }

        public bool Post(Token token, TValue value) {
            RollbackTmpStack();
            _error = false;
            while (StackTop().Entry.State(token, value))
                ; // may throw
            if (!_error) {
                CommitTmpStack();
            } else {
                Recover(token, value);
            }
            return _accepted || _error;
        }

        public bool Accept(out TValue value) {
            Debug.Assert(_accepted);
            value = default;
            if (_error) { return false; }
            value = _acceptedValue;
            return true;
        }

        public bool Error() { return _error; }

        delegate bool StateType(Token token, TValue value);
        delegate int GotoType(NonTerminal nonTerminal);

        private readonly ISemanticAction<TValue> _action;
        private bool _accepted;
        private bool _error;
        private TValue _acceptedValue;

        private readonly struct TableEntry
        {
            public readonly StateType State;
            public readonly GotoType Goto;
            public readonly bool HandleError;
            public TableEntry(StateType statef, GotoType gotof, bool handleError) {
                State = statef;
                Goto = gotof;
                HandleError = handleError;
            }
        }

        private readonly struct StackFrame
        {
            public readonly TableEntry Entry;
            public readonly TValue Value;
            public readonly int SequenceLength;
            public StackFrame(TableEntry entry, TValue value, int sequenceLength) {
                Entry = entry;
                Value = value;
                SequenceLength = sequenceLength;
            }
        }

        readonly List<TableEntry> _entries;
        readonly Stack<StackFrame> _stack;

        bool PushStack(int stateIndex, TValue value, int sequenceLength = 0) {
            var f = _stack.Push(new StackFrame(_entries[stateIndex], value, sequenceLength));
            Debug.Assert(!_error);
            if (!f) {
                _error = true;
                _action.StackOverflow();
            }
            return f;
        }

        void PopStack(int n) {
            _stack.Pop(n);
        }

        StackFrame StackTop() {
            return _stack.Top();
        }

        TValue GetArg(int @base, int index) {
            return _stack[@base, index].Value;
        }

        void ClearStack() {
            _stack.Clear();
        }

        void RollbackTmpStack() {
            _stack.RollbackTmp();
        }

        void CommitTmpStack() {
            _stack.CommitTmp();
        }

        void Recover(Token token, TValue value) {
        }

        bool CallNothing(NonTerminal nonTerminal, int @base) {
            PopStack(@base);
            var destIndex = StackTop().Entry.Goto(nonTerminal);
            return PushStack(destIndex, default);
        }

        bool Call0Identity(NonTerminal nonTerminal, int @base, int arg0Index) {
            var arg0 = _action.Toint(GetArg(@base, arg0Index));
            var r = _action.Identity(arg0);
            var v = _action.Fromint(r);
            PopStack(@base);
            var destIndex = StackTop().Entry.Goto(nonTerminal);
            return PushStack(destIndex, v);
        }

        bool Call0MakeDiv(NonTerminal nonTerminal, int @base, int arg0Index, int arg1Index) {
            var arg0 = _action.Toint(GetArg(@base, arg0Index));
            var arg1 = _action.Toint(GetArg(@base, arg1Index));
            var r = _action.MakeDiv(arg0, arg1);
            var v = _action.Fromint(r);
            PopStack(@base);
            var destIndex = StackTop().Entry.Goto(nonTerminal);
            return PushStack(destIndex, v);
        }

        bool Call0MakeMul(NonTerminal nonTerminal, int @base, int arg0Index, int arg1Index) {
            var arg0 = _action.Toint(GetArg(@base, arg0Index));
            var arg1 = _action.Toint(GetArg(@base, arg1Index));
            var r = _action.MakeMul(arg0, arg1);
            var v = _action.Fromint(r);
            PopStack(@base);
            var destIndex = StackTop().Entry.Goto(nonTerminal);
            return PushStack(destIndex, v);
        }

        bool Call0MakeAdd(NonTerminal nonTerminal, int @base, int arg0Index, int arg1Index) {
            var arg0 = _action.Toint(GetArg(@base, arg0Index));
            var arg1 = _action.Toint(GetArg(@base, arg1Index));
            var r = _action.MakeAdd(arg0, arg1);
            var v = _action.Fromint(r);
            PopStack(@base);
            var destIndex = StackTop().Entry.Goto(nonTerminal);
            return PushStack(destIndex, v);
        }

        bool Call0MakeSub(NonTerminal nonTerminal, int @base, int arg0Index, int arg1Index) {
            var arg0 = _action.Toint(GetArg(@base, arg0Index));
            var arg1 = _action.Toint(GetArg(@base, arg1Index));
            var r = _action.MakeSub(arg0, arg1);
            var v = _action.Fromint(r);
            PopStack(@base);
            var destIndex = StackTop().Entry.Goto(nonTerminal);
            return PushStack(destIndex, v);
        }

        bool State0(Token token, TValue value) {
            switch(token) {
            case Token.token_Number:
                // Shift
                PushStack(/*State*/ 7, value);
                return false;
            default:
                _action.SyntaxError();
                _error = true;
                return false;
            }
        }

        int Goto0(NonTerminal nonTerminal) {
            switch(nonTerminal) {
            case NonTerminal.NonTerminal_Term: return 2;
            case NonTerminal.NonTerminal_Expr: return 1;
            default: Debug.Assert(false); return 0;
            }
        }

        bool State1(Token token, TValue value) {
            switch(token) {
            case Token.token_eof:
                // Accept
                _accepted = true;
                _acceptedValue = GetArg(1, 0);
                return false;
            case Token.token_Add:
                // Shift
                PushStack(/*State*/ 3, value);
                return false;
            case Token.token_Sub:
                // Shift
                PushStack(/*State*/ 5, value);
                return false;
            default:
                _action.SyntaxError();
                _error = true;
                return false;
            }
        }

        int Goto1(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State2(Token token, TValue value) {
            switch(token) {
            case Token.token_Div:
                // Shift
                PushStack(/*State*/ 10, value);
                return false;
            case Token.token_Mul:
                // Shift
                PushStack(/*State*/ 8, value);
                return false;
            case Token.token_eof:
            case Token.token_Add:
            case Token.token_Sub:
                // Reduce
                return Call0Identity(NonTerminal.NonTerminal_Expr, /*Pop*/ 1, 0);
            default:
                _action.SyntaxError();
                _error = true;
                return false;
            }
        }

        int Goto2(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State3(Token token, TValue value) {
            switch(token) {
            case Token.token_Number:
                // Shift
                PushStack(/*State*/ 7, value);
                return false;
            default:
                _action.SyntaxError();
                _error = true;
                return false;
            }
        }

        int Goto3(NonTerminal nonTerminal) {
            switch(nonTerminal) {
            case NonTerminal.NonTerminal_Term: return 4;
            default: Debug.Assert(false); return 0;
            }
        }

        bool State4(Token token, TValue value) {
            switch(token) {
            case Token.token_Div:
                // Shift
                PushStack(/*State*/ 10, value);
                return false;
            case Token.token_Mul:
                // Shift
                PushStack(/*State*/ 8, value);
                return false;
            case Token.token_eof:
            case Token.token_Add:
            case Token.token_Sub:
                // Reduce
                return Call0MakeAdd(NonTerminal.NonTerminal_Expr, /*Pop*/ 3, 0, 2);
            default:
                _action.SyntaxError();
                _error = true;
                return false;
            }
        }

        int Goto4(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State5(Token token, TValue value) {
            switch(token) {
            case Token.token_Number:
                // Shift
                PushStack(/*State*/ 7, value);
                return false;
            default:
                _action.SyntaxError();
                _error = true;
                return false;
            }
        }

        int Goto5(NonTerminal nonTerminal) {
            switch(nonTerminal) {
            case NonTerminal.NonTerminal_Term: return 6;
            default: Debug.Assert(false); return 0;
            }
        }

        bool State6(Token token, TValue value) {
            switch(token) {
            case Token.token_Div:
                // Shift
                PushStack(/*State*/ 10, value);
                return false;
            case Token.token_Mul:
                // Shift
                PushStack(/*State*/ 8, value);
                return false;
            case Token.token_eof:
            case Token.token_Add:
            case Token.token_Sub:
                // Reduce
                return Call0MakeSub(NonTerminal.NonTerminal_Expr, /*Pop*/ 3, 0, 2);
            default:
                _action.SyntaxError();
                _error = true;
                return false;
            }
        }

        int Goto6(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State7(Token token, TValue value) {
            switch(token) {
            case Token.token_eof:
            case Token.token_Add:
            case Token.token_Div:
            case Token.token_Mul:
            case Token.token_Sub:
                // Reduce
                return Call0Identity(NonTerminal.NonTerminal_Term, /*Pop*/ 1, 0);
            default:
                _action.SyntaxError();
                _error = true;
                return false;
            }
        }

        int Goto7(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State8(Token token, TValue value) {
            switch(token) {
            case Token.token_Number:
                // Shift
                PushStack(/*State*/ 9, value);
                return false;
            default:
                _action.SyntaxError();
                _error = true;
                return false;
            }
        }

        int Goto8(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State9(Token token, TValue value) {
            switch(token) {
            case Token.token_eof:
            case Token.token_Add:
            case Token.token_Div:
            case Token.token_Mul:
            case Token.token_Sub:
                // Reduce
                return Call0MakeMul(NonTerminal.NonTerminal_Term, /*Pop*/ 3, 0, 2);
            default:
                _action.SyntaxError();
                _error = true;
                return false;
            }
        }

        int Goto9(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State10(Token token, TValue value) {
            switch(token) {
            case Token.token_Number:
                // Shift
                PushStack(/*State*/ 11, value);
                return false;
            default:
                _action.SyntaxError();
                _error = true;
                return false;
            }
        }

        int Goto10(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

        bool State11(Token token, TValue value) {
            switch(token) {
            case Token.token_eof:
            case Token.token_Add:
            case Token.token_Div:
            case Token.token_Mul:
            case Token.token_Sub:
                // Reduce
                return Call0MakeDiv(NonTerminal.NonTerminal_Term, /*Pop*/ 3, 0, 2);
            default:
                _action.SyntaxError();
                _error = true;
                return false;
            }
        }

        int Goto11(NonTerminal nonTerminal) {
            Debug.Assert(false);
            return 0;
        }

    }
}
